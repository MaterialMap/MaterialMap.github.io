<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swift's Law Calculator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .input-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .input-item {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #34495e;
        }
        input, select {
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            font-size: 16px;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
        }
        .unit-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .result-item {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .result-name {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        .result-value {
            font-size: 18px;
            color: #e74c3c;
            font-family: 'Courier New', monospace;
        }
        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }
        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid #bdc3c7;
        }
        th {
            background: #34495e;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        .chart-container {
            margin-top: 20px;
            text-align: center;
        }
        #stressStrainChart {
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            background: white;
        }
        .export-btn {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        .export-btn:hover {
            background: linear-gradient(135deg, #219a52, #27ae60);
        }
        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Swift's Law Calculator for Metal Strain Hardening</h1>
        
        <div style="text-align: center; margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db;">
            <h2 style="margin: 0; color: #2c3e50; font-size: 24px;">Swift's Law Formula</h2>
            <div style="font-size: 28px; font-weight: bold; margin: 15px 0; color: #e74c3c; font-family: 'Times New Roman', serif;">
                œÉ = K(Œµ‚ÇÄ + Œµ)‚Åø
            </div>
            <div style="font-size: 14px; color: #7f8c8d; line-height: 1.5;">
                <strong>where:</strong> œÉ - true stress, K - strength coefficient, Œµ‚ÇÄ - initial strain, Œµ - plastic strain, n - hardening exponent
            </div>
        </div>
        
        <div class="unit-selector">
            <label for="pressureUnit"><strong>Pressure Units:</strong></label>
            <select id="pressureUnit" onchange="updateUnits()">
                <option value="Pa">Pa</option>
                <option value="kPa">kPa</option>
                <option value="MPa" selected>MPa</option>
                <option value="GPa">GPa</option>
            </select>
        </div>

        <div class="input-group">
            <div class="input-item">
                <label for="youngModulus">Young's Modulus E, <span id="unit1">MPa</span>:</label>
                <input type="number" id="youngModulus" step="any" value="200000" oninput="scheduleCalculation()">
            </div>
            <div class="input-item">
                <label for="yieldStrength">Yield Strength (œÉ<sub>y</sub>), <span id="unit2">MPa</span>:</label>
                <input type="number" id="yieldStrength" step="any" value="349.1" oninput="scheduleCalculation()">
            </div>
            <div class="input-item">
                <label for="tensileStrength">Ultimate Tensile Strength (œÉ<sub>u</sub>), <span id="unit3">MPa</span>:</label>
                <input type="number" id="tensileStrength" step="any" value="687.4" oninput="scheduleCalculation()">
            </div>
            <div class="input-item">
                <label for="elongation">Elongation at Break (A):</label>
                <input type="number" id="elongation" step="any" value="0.08" oninput="scheduleCalculation()">
            </div>
            <div class="input-item">
                <label for="epsilon0">Residual Plastic Strain (Œµ‚ÇÄ):</label>
                <input type="number" id="epsilon0" step="any" value="0" oninput="scheduleCalculation()">
            </div>
        </div>

        <div class="results" id="results" style="display: none;">
            <div class="result-item">
                <div class="result-name">Ultimate Tensile Strength (True) œÉ<sub>u,true</sub></div>
                <div class="result-value" id="trueTensileStrength">-</div>
            </div>
            <div class="result-item">
                <div class="result-name">Hardening Exponent (n)</div>
                <div class="result-value" id="hardeningExponent">-</div>
            </div>
            <div class="result-item">
                <div class="result-name">Strength Coefficient (K)</div>
                <div class="result-value" id="strengthCoefficient">-</div>
            </div>
            <div class="result-item">
                <div class="result-name">Residual Plastic Strain (Œµ<sub>0</sub>)</div>
                <div class="result-value" id="residualStrain">-</div>
            </div>
            <div class="result-item">
                <div class="result-name">Tangent Modulus (E<sub>tan</sub>)</div>
                <div class="result-value" id="tangentModulus">-</div>
            </div>
        </div>
    </div>

    <div class="container" id="chartContainer" style="display: none;">
        <h2>Stress-Strain Curve</h2>
        <div class="chart-container">
            <svg id="stressStrainChart" width="900" height="500" xmlns="http://www.w3.org/2000/svg">
            </svg>
        </div>
    </div>

    <div class="container" id="tableContainer" style="display: none;">
        <div class="table-header">
            <h2>Strain-Stress Data Table</h2>
            <button class="export-btn" onclick="exportToCSV()">üìä Export CSV</button>
        </div>
        <div class="table-container">
            <table id="strainTable">
                <thead>
                    <tr>
                        <th>Total Strain (Œµ<sub>total</sub>)</th>
                        <th>Plastic Strain (Œµ<sub>plastic</sub>)</th>
                        <th>True Stress (œÉ), <span id="stressUnit">MPa</span></th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                </tbody>
            </table>
        </div>
    </div>

    <div class="container" id="curveContainer" style="display: none;">
        <h2>LS-DYNA *DEFINE_CURVE_STRESS</h2>
        <div style="background: #f8f9fa; border: 1px solid #bdc3c7; border-radius: 8px; padding: 20px; margin-top: 20px;">
            <pre id="defineCurveStress" style="font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; margin: 0; white-space: pre; overflow-x: auto;"></pre>
        </div>
        <button class="export-btn" onclick="copyToClipboard()" style="margin-top: 15px;">üìã Copy to Clipboard</button>
    </div>

    <script>
        let calculatedValues = {};
        let calculationTimeout = null;

        function updateUnits() {
            const unit = document.getElementById('pressureUnit').value;
            document.getElementById('unit1').textContent = unit;
            document.getElementById('unit2').textContent = unit;
            document.getElementById('unit3').textContent = unit;
            document.getElementById('stressUnit').textContent = unit;
            scheduleCalculation();
        }

        function getUnitMultiplier(unit) {
            switch(unit) {
                case 'Pa': return 1e6;      // Convert from MPa to Pa
                case 'kPa': return 1e3;     // Convert from MPa to kPa
                case 'MPa': return 1;       // Base unit
                case 'GPa': return 1e-3;    // Convert from MPa to GPa
                default: return 1;
            }
        }

        function convertStressValue(value, unit) {
            return value * getUnitMultiplier(unit);
        }

        function scheduleCalculation() {
            if (calculationTimeout) {
                clearTimeout(calculationTimeout);
            }
            calculationTimeout = setTimeout(calculate, 300);
        }

        function formatScientific(value, decimals = 2) {
            if (Math.abs(value) < 0.001 || Math.abs(value) >= 10000) {
                return value.toExponential(decimals);
            }
            return value.toFixed(decimals);
        }

        function calculate() {
            try {
                // Get input data and convert to base units (MPa)
                const unit = document.getElementById('pressureUnit').value;
                const unitMultiplier = getUnitMultiplier(unit);
                
                const E = parseFloat(document.getElementById('youngModulus').value) / unitMultiplier;
                const sigma_y = parseFloat(document.getElementById('yieldStrength').value) / unitMultiplier;
                const sigma_u = parseFloat(document.getElementById('tensileStrength').value) / unitMultiplier;
                const A = parseFloat(document.getElementById('elongation').value);
                const epsilon_0 = parseFloat(document.getElementById('epsilon0').value);

                if (isNaN(E) || isNaN(sigma_y) || isNaN(sigma_u) || isNaN(A) || isNaN(epsilon_0)) {
                    hideResults();
                    return;
                }

                if (E <= 0 || sigma_y <= 0 || sigma_u <= 0 || A <= 0 || sigma_u <= sigma_y) {
                    hideResults();
                    return;
                }

                // Calculate output parameters
                const sigma_u_true = sigma_u * (1 + A);
                const elasticLimit = sigma_y / E;
                const plasticStrainAtBreak = A - elasticLimit;
                
                // Swift's law: œÉ = K(Œµ‚ÇÄ + Œµ_plastic)‚Åø
                let n, K;
                
                if (epsilon_0 === 0) {
                    // Traditional Swift's law: œÉ = K(Œµ_plastic)‚Åø
                    // Use the original calculation method when epsilon_0 = 0
                    n = Math.log(sigma_y / sigma_u_true) / Math.log(sigma_y / (E * Math.log(1 + A)));
                    K = Math.pow(E, n) * Math.pow(sigma_y, 1 - n);
                } else {
                    // Modified Swift's law with initial strain: œÉ = K(Œµ‚ÇÄ + Œµ_plastic)‚Åø
                    // At yield point: œÉ_y = K(Œµ‚ÇÄ)‚Åø  
                    // At ultimate point: œÉ_u_true = K(Œµ‚ÇÄ + Œµ_plastic_at_break)‚Åø
                    n = Math.log(sigma_u_true / sigma_y) / Math.log((epsilon_0 + plasticStrainAtBreak) / epsilon_0);
                    K = sigma_y / Math.pow(epsilon_0, n);
                }
                
                const eps_y = epsilon_0; // This is the input parameter now
                const E_tan = (sigma_u_true - sigma_y) / A;

                // Check for NaN in results
                if (isNaN(n) || isNaN(K) || isNaN(eps_y) || isNaN(E_tan)) {
                    hideResults();
                    return;
                }

                // Save calculated values
                calculatedValues = { E, sigma_y, sigma_u, A, epsilon_0, sigma_u_true, n, K, eps_y, E_tan, unit };

                // Display results (convert to selected units)
                document.getElementById('trueTensileStrength').textContent = `${formatScientific(convertStressValue(sigma_u_true, unit))} ${unit}`;
                document.getElementById('hardeningExponent').textContent = formatScientific(n);
                document.getElementById('strengthCoefficient').textContent = `${formatScientific(convertStressValue(K, unit))} ${unit}`;
                document.getElementById('residualStrain').textContent = formatScientific(eps_y);
                document.getElementById('tangentModulus').textContent = `${formatScientific(convertStressValue(E_tan, unit))} ${unit}`;

                document.getElementById('results').style.display = 'grid';

                // Generate table, chart and curve definition
                generateTable();
                drawChart();
                generateDefineCurveStress();
                document.getElementById('tableContainer').style.display = 'block';
                document.getElementById('chartContainer').style.display = 'block';
                document.getElementById('curveContainer').style.display = 'block';

            } catch (error) {
                console.error('Calculation error:', error);
                hideResults();
            }
        }

        function hideResults() {
            document.getElementById('results').style.display = 'none';
            document.getElementById('tableContainer').style.display = 'none';
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('curveContainer').style.display = 'none';
        }

        function generateTable() {
            try {
                const { E, sigma_y, n, K, eps_y, A, epsilon_0, unit } = calculatedValues;
                const tableBody = document.getElementById('tableBody');
                tableBody.innerHTML = '';

                const maxStrain = A * 1.1;
                const steps = 50;
                const strainStep = maxStrain / steps;
                const elasticLimit = sigma_y / E;

                for (let i = 0; i <= steps; i++) {
                    const totalStrain = i * strainStep;
                    let plasticStrain, stress;

                    if (totalStrain <= elasticLimit) {
                        plasticStrain = 0;
                        stress = E * totalStrain;
                    } else {
                        plasticStrain = totalStrain - elasticLimit;
                        if (epsilon_0 === 0) {
                            // Traditional Swift's law: œÉ = K(Œµ_plastic)‚Åø
                            const eps_y_calc = Math.pow(E / K, 1 / (n - 1));
                            stress = K * Math.pow(eps_y_calc + plasticStrain, n);
                        } else {
                            // Modified Swift's law: œÉ = K(Œµ‚ÇÄ + Œµ_plastic)‚Åø
                            stress = K * Math.pow(epsilon_0 + plasticStrain, n);
                        }
                    }

                    const row = tableBody.insertRow();
                    row.insertCell(0).textContent = formatScientific(totalStrain, 4);
                    row.insertCell(1).textContent = formatScientific(plasticStrain, 4);
                    row.insertCell(2).textContent = formatScientific(convertStressValue(stress, unit), 2);
                }
            } catch (error) {
                console.error('Table generation error:', error);
            }
        }

        function drawChart() {
            try {
                const svg = document.getElementById('stressStrainChart');
                const { E, sigma_y, n, K, eps_y, A, epsilon_0, unit } = calculatedValues;

                // Clear SVG
                svg.innerHTML = '';

                const maxStrain = A * 1.2; // +20% for necking area
                const elasticLimit = sigma_y / E;
                const maxStressBase = Math.max(K * Math.pow(eps_y + A, n), sigma_y * 1.2) * 1.1; // +10% for necking area
                const maxStress = convertStressValue(maxStressBase, unit); // Convert to display units

                // Set up coordinates with space for right legend
                const padding = 80;
                const rightPadding = 180; // Space for right legend
                const bottomPadding = 100; // More space for axis labels
                const topPadding = 40;
                const chartWidth = 900 - padding - rightPadding;
                const chartHeight = 500 - topPadding - bottomPadding;

                // Coordinate transformation functions
                const xScale = (strain) => padding + (strain / maxStrain) * chartWidth;
                const yScale = (stress) => 500 - bottomPadding - (stress / maxStress) * chartHeight;

                // Create SVG elements
                const createLine = (x1, y1, x2, y2, color, width = 1, dash = '') => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', color);
                    line.setAttribute('stroke-width', width);
                    if (dash) line.setAttribute('stroke-dasharray', dash);
                    return line;
                };

                const createPath = (d, color, width = 1, fill = 'none') => {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', width);
                    path.setAttribute('fill', fill);
                    return path;
                };

                const createCircle = (cx, cy, r, color) => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', cx);
                    circle.setAttribute('cy', cy);
                    circle.setAttribute('r', r);
                    circle.setAttribute('fill', color);
                    return circle;
                };

                const createText = (x, y, text, size = 12, color = '#2c3e50', anchor = 'start', transform = '') => {
                    const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    textEl.setAttribute('x', x);
                    textEl.setAttribute('y', y);
                    textEl.setAttribute('fill', color);
                    textEl.setAttribute('font-size', size);
                    textEl.setAttribute('font-family', 'Arial, sans-serif');
                    textEl.setAttribute('text-anchor', anchor);
                    if (transform) textEl.setAttribute('transform', transform);
                    textEl.textContent = text;
                    return textEl;
                };

                // Draw grid
                for (let i = 1; i <= 10; i++) {
                    const x = padding + (i / 10) * chartWidth;
                    const y = topPadding + (i / 10) * chartHeight;
                    
                    svg.appendChild(createLine(x, topPadding, x, 500 - bottomPadding, '#e8e8e8', 1));
                    svg.appendChild(createLine(padding, y, 900 - rightPadding, y, '#e8e8e8', 1));
                }

                // Draw axes
                svg.appendChild(createLine(padding, topPadding, padding, 500 - bottomPadding, '#2c3e50', 2));
                svg.appendChild(createLine(padding, 500 - bottomPadding, 900 - rightPadding, 500 - bottomPadding, '#2c3e50', 2));

                // Axis labels - positioned to not overlap with value labels
                svg.appendChild(createText(padding + chartWidth/2, 490, 'Total Strain (Œµ)', 14, '#2c3e50', 'middle'));
                svg.appendChild(createText(25, topPadding + chartHeight/2, `True Stress œÉ (${unit})`, 14, '#2c3e50', 'middle', `rotate(-90, 25, ${topPadding + chartHeight/2})`));

                // 1. Red elasticity line - make it visible
                svg.appendChild(createLine(xScale(0), yScale(0), xScale(elasticLimit), yScale(convertStressValue(sigma_y, unit)), '#e74c3c', 4));

                // 2. Blue Swift's law curve - ONLY for plastic region
                const steps = 200;
                const plasticStrainRange = A - elasticLimit; // Only to elongation at break
                const strainStep = plasticStrainRange / steps;
                let pathData = '';
                let maxStressPoint = { strain: elasticLimit, stress: sigma_y };

                // Start from yield point
                pathData += `M ${xScale(elasticLimit)} ${yScale(convertStressValue(sigma_y, unit))} `;

                for (let i = 1; i <= steps; i++) {
                    const totalStrain = elasticLimit + i * strainStep;
                    const plasticStrain = totalStrain - elasticLimit;
                    let stress;
                    
                    if (epsilon_0 === 0) {
                        // Traditional Swift's law: œÉ = K(Œµ_plastic)‚Åø
                        const eps_y_calc = Math.pow(E / K, 1 / (n - 1));
                        stress = K * Math.pow(eps_y_calc + plasticStrain, n);
                    } else {
                        // Modified Swift's law: œÉ = K(Œµ‚ÇÄ + Œµ_plastic)‚Åø
                        stress = K * Math.pow(epsilon_0 + plasticStrain, n);
                    }
                    
                    if (stress > maxStressPoint.stress) {
                        maxStressPoint = { strain: totalStrain, stress: stress };
                    }

                    const x = xScale(totalStrain);
                    const y = yScale(convertStressValue(stress, unit));
                    pathData += `L ${x} ${y} `;
                }
                svg.appendChild(createPath(pathData, '#3498db', 3));

                // 3. Green linear approximation line
                const endStrain = A;
                let endStress;
                
                if (epsilon_0 === 0) {
                    // Traditional Swift's law: œÉ = K(Œµ_plastic)‚Åø
                    const eps_y_calc = Math.pow(E / K, 1 / (n - 1));
                    endStress = K * Math.pow(eps_y_calc + (endStrain - elasticLimit), n);
                } else {
                    // Modified Swift's law: œÉ = K(Œµ‚ÇÄ + Œµ_plastic)‚Åø
                    endStress = K * Math.pow(epsilon_0 + (endStrain - elasticLimit), n);
                }
                svg.appendChild(createLine(xScale(elasticLimit), yScale(convertStressValue(sigma_y, unit)), xScale(endStrain), yScale(convertStressValue(endStress, unit)), '#27ae60', 3));

                // Yield point
                svg.appendChild(createCircle(xScale(elasticLimit), yScale(convertStressValue(sigma_y, unit)), 6, '#f39c12'));

                // Maximum point
                svg.appendChild(createCircle(xScale(maxStressPoint.strain), yScale(convertStressValue(maxStressPoint.stress, unit)), 6, '#8e44ad'));

                // Necking arrow - UNDER the curve
                const neckingX = xScale(maxStressPoint.strain);
                const neckingY = yScale(convertStressValue(maxStressPoint.stress, unit));
                
                // Arrow pointing up from below
                svg.appendChild(createLine(neckingX, neckingY + 30, neckingX, neckingY + 10, '#2c3e50', 2));
                
                // Arrow head pointing up
                const arrowPath = `M ${neckingX - 5} ${neckingY + 15} L ${neckingX} ${neckingY + 10} L ${neckingX + 5} ${neckingY + 15}`;
                svg.appendChild(createPath(arrowPath, '#2c3e50', 2));

                svg.appendChild(createText(neckingX, neckingY + 45, 'Necking', 12, '#2c3e50', 'middle'));

                // RIGHT LEGEND - centered vertically
                const legendItems = [
                    { color: '#e74c3c', text: 'Elasticity' },
                    { color: '#3498db', text: 'Swift Law' },
                    { color: '#27ae60', text: 'Linear Approximation' }
                ];

                const legendStartY = topPadding + chartHeight/2 - (legendItems.length * 25)/2;
                let legendY = legendStartY;
                const legendX = 900 - rightPadding + 20;

                legendItems.forEach((item) => {
                    svg.appendChild(createLine(legendX, legendY, legendX + 25, legendY, item.color, 3));
                    svg.appendChild(createText(legendX + 30, legendY + 4, item.text, 12));
                    legendY += 25;
                });

                // Axis value labels - positioned to avoid overlap
                for (let i = 0; i <= 10; i++) {
                    const strainValue = (maxStrain * i / 10).toFixed(3);
                    const x = padding + (i / 10) * chartWidth;
                    svg.appendChild(createText(x, 460, strainValue, 10, '#7f8c8d', 'middle'));
                }
                
                for (let i = 0; i <= 10; i++) {
                    const stressValue = Math.round(maxStress * i / 10).toString();
                    const y = 500 - bottomPadding - (i / 10) * chartHeight;
                    svg.appendChild(createText(padding - 15, y + 3, stressValue, 10, '#7f8c8d', 'end'));
                }

            } catch (error) {
                console.error('SVG chart drawing error:', error);
            }
        }

        function exportToCSV() {
            if (!calculatedValues || Object.keys(calculatedValues).length === 0) {
                alert('No data available for export. Please enter valid parameters.');
                return;
            }

            const { E, sigma_y, n, K, eps_y, A, epsilon_0, unit } = calculatedValues;
            
            let csvContent = "Total Strain (Œµ_total),Plastic Strain (Œµ_plastic),True Stress œÉ (" + unit + ")\n";
            
            const maxStrain = A * 1.1;
            const steps = 50;
            const strainStep = maxStrain / steps;
            const elasticLimit = sigma_y / E;

            for (let i = 0; i <= steps; i++) {
                const totalStrain = i * strainStep;
                let plasticStrain, stress;

                if (totalStrain <= elasticLimit) {
                    plasticStrain = 0;
                    stress = E * totalStrain;
                } else {
                    plasticStrain = totalStrain - elasticLimit;
                    if (epsilon_0 === 0) {
                        // Traditional Swift's law: œÉ = K(Œµ_plastic)‚Åø
                        const eps_y_calc = Math.pow(E / K, 1 / (n - 1));
                        stress = K * Math.pow(eps_y_calc + plasticStrain, n);
                    } else {
                        // Modified Swift's law: œÉ = K(Œµ‚ÇÄ + Œµ_plastic)‚Åø
                        stress = K * Math.pow(epsilon_0 + plasticStrain, n);
                    }
                }

                csvContent += totalStrain.toExponential(6) + "," + 
                             plasticStrain.toExponential(6) + "," + 
                             convertStressValue(stress, unit).toExponential(6) + "\n";
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                
                const now = new Date();
                const timestamp = now.getFullYear() + '-' + 
                                String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                                String(now.getDate()).padStart(2, '0') + '_' + 
                                String(now.getHours()).padStart(2, '0') + '-' + 
                                String(now.getMinutes()).padStart(2, '0');
                
                link.setAttribute('download', 'swift_law_data_' + timestamp + '.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function generateDefineCurveStress() {
            try {
                const { n, K, epsilon_0, unit } = calculatedValues;
                
                // Convert K to MPa for LS-DYNA (base units)
                const K_MPa = K; // K is already in base units (MPa)
                
                // Format values with proper positioning (right-aligned in their columns)
                // K: positions 21-30, n: positions 31-40, eps_0: positions 41-50
                const K_str = formatScientific(K_MPa, 4);
                const n_str = formatScientific(n, 4);
                const eps0_str = formatScientific(epsilon_0, 4);
                
                // Build the line with exact positioning
                let line5 = '         1         1'; // LCID=1, ITYPE=1 (positions 1-20)
                line5 += K_str.padStart(10);        // K at positions 21-30
                line5 += n_str.padStart(10);        // n at positions 31-40
                line5 += eps0_str.padStart(10);     // eps_0 at positions 41-50
                
                const curveDefinition = `*DEFINE_CURVE_STRESS
$ Pressure units: ${calculatedValues.unit}
$ ITYPE is Type of hardening law. EQ.1: Swift power law
$--------1---------2---------3---------4---------5---------6---------7---------8
$#    LCID     ITYPE      P1=K      P2=n  P3=eps_0
${line5}
$--------1---------2---------3---------4---------5---------6---------7---------8`;

                document.getElementById('defineCurveStress').textContent = curveDefinition;
            } catch (error) {
                console.error('DEFINE_CURVE_STRESS generation error:', error);
            }
        }

        function copyToClipboard() {
            const text = document.getElementById('defineCurveStress').textContent;
            navigator.clipboard.writeText(text).then(function() {
                // Visual feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úÖ Copied!';
                button.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                }, 2000);
            }).catch(function(err) {
                console.error('Could not copy text: ', err);
                alert('Failed to copy to clipboard. Please copy manually.');
            });
        }

        // Page initialization
        window.onload = function() {
            updateUnits();
            calculate();
        };
    </script>
</body>
</html>